// =============================================================================
// Archivo: comandos_mongodb.js
// Descripción: Script con operaciones CRUD y Pipeline de Agregación para la
//              colección 'lecturas_sensores' en MongoDB, simulando un
//              sistema de monitoreo ambiental IoT.
// =============================================================================

// Seleccionar la base de datos de trabajo
// Asegúrate de que esta base de datos exista o se creará al insertar el primer documento.
use ambiental_iot;

print("--- Iniciando operaciones CRUD y Agregación en la base de datos 'ambiental_iot' ---");

// =============================================================================
// 1. VERIFICACIÓN INICIAL (OPCIONAL)
// =============================================================================

print("\n--- 1.0. Verificación inicial de documentos en la colección ---");
// Muestra los primeros 5 documentos para tener una idea de la estructura
db.lecturas_sensores.find({}).limit(5);

// =============================================================================
// 2. OPERACIONES CRUD (Create, Read, Update, Delete)
// =============================================================================

// --- 2.1. CREATE (Crear/Insertar documentos) ---
print("\n--- 2.1. Insertando un nuevo documento de sensor (CREATE) ---");
// Simula la llegada de una nueva lectura de un sensor recién instalado o reactivado.
db.lecturas_sensores.insertOne(
    {
        "sensor_id": "SNSR-NEW-007",
        "ubicacion": {
            "ciudad": "Santa Marta",
            "pais": "Colombia",
            "latitud": 11.233,
            "longitud": -74.200
        },
        "timestamp": new Date(), // Fecha y hora actual
        "tipo_sensor": "Calidad del Aire",
        "metadatos": {
            "fabricante": "IoTTech",
            "modelo": "AQI-Pro",
            "firmware_version": "1.2.0",
            "estado_bateria": 95,
            "ultima_actualizacion": new Date()
        },
        "mediciones": {
            "temperatura": 28.5,    // Grados Celsius
            "humedad": 80.2,        // Porcentaje
            "presion_atmosferica": 1010.5, // hPa
            "pm2_5": 35.8,          // µg/m³ (partículas finas)
            "pm10": 60.1,           // µg/m³ (partículas gruesas)
            "o3": 0.045,            // ppm (ozono)
            "co": 3.2,              // ppm (monóxido de carbono)
            "no2": 0.021            // ppm (dióxido de nitrógeno)
        }
    }
);

// --- 2.2. READ (Leer/Consultar documentos) ---
print("\n--- 2.2. Consultando documentos (READ) ---");

// 2.2.1. Encontrar un documento por su ID de sensor específico
print("\n   --- 2.2.1. Buscando el sensor recién insertado (SNSR-NEW-007) ---");
db.lecturas_sensores.findOne({"sensor_id": "SNSR-NEW-007"});

// 2.2.2. Encontrar documentos con un filtro y proyección (solo campos específicos)
print("\n   --- 2.2.2. Lecturas de Bogotá con PM2.5 y temperatura (filtrado y proyección) ---");
// Muestra el sensor_id, ciudad, pm2_5 y temperatura de las lecturas de Bogotá, limitado a 5 resultados.
db.lecturas_sensores.find(
    {"ubicacion.ciudad": "Bogota"},
    {
        "sensor_id": 1,
        "ubicacion.ciudad": 1,
        "mediciones.pm2_5": 1,
        "mediciones.temperatura": 1,
        "timestamp": 1,
        "_id": 0 // Excluir el campo _id
    }
).limit(5).pretty();

// 2.2.3. Encontrar documentos que cumplen una condición de valor (PM2.5 alta)
print("\n   --- 2.2.3. Lecturas con PM2.5 superior a 50 ---");
// Busca lecturas donde el nivel de PM2.5 excede un umbral de seguridad.
db.lecturas_sensores.find(
    {"mediciones.pm2_5": {"$gt": 50}},
    {"sensor_id": 1, "ubicacion.ciudad": 1, "mediciones.pm2_5": 1, "timestamp": 1, "_id": 0}
).limit(10).pretty();

// --- 2.3. UPDATE (Actualizar documentos) ---
print("\n--- 2.3. Actualizando documentos (UPDATE) ---");

// 2.3.1. Actualizar un solo documento: Cambiar el estado de batería y última actualización de un sensor específico
print("\n   --- 2.3.1. Actualizando estado de batería del SNSR-NEW-007 ---");
// Simula el mantenimiento de un sensor (cambio de batería o actualización de firmware).
db.lecturas_sensores.updateOne(
    {"sensor_id": "SNSR-NEW-007"},
    {
        "$set": {
            "metadatos.estado_bateria": 100, // Batería al 100%
            "metadatos.ultima_actualizacion": new Date() // Actualizar fecha de mantenimiento
        }
    }
);

// 2.3.2. Actualizar múltiples documentos: Aumentar el valor de pm2_5 en un 10% para todos los sensores de Bogotá
// --- EXPLICACIÓN DETALLADA PARA EL TUTOR ---
// Esta operación simula un AJUSTE DE CALIBRACIÓN o la propagación de un error de lectura detectado.
// CASO DE USO: Si se determina, por ejemplo, que los sensores de calidad del aire en Bogotá
// han estado sistemáticamente SUBESTIMANDO los niveles reales de PM2.5 en un 10% (quizás por un lote defectuoso
// o una calibración inicial errónea detectada con sensores de referencia).
// Esta actualización permite CORREGIR RETROACTIVAMENTE los datos históricos ya registrados
// para esos sensores específicos en esa ciudad. Esto es crucial para mantener la precisión
// y la fiabilidad de los datos a lo largo del tiempo, lo cual es vital para el análisis ambiental
// y el cumplimiento normativo.
// --- FIN DE EXPLICACIÓN ---
print("\n   --- 2.3.2. Aumentando PM2.5 en un 10% para sensores de Bogotá ($mul) ---");
db.lecturas_sensores.updateMany(
    {"ubicacion.ciudad": "Bogota"}, // Filtro: todos los documentos de Bogotá
    {"$mul": {"mediciones.pm2_5": 1.1}} // Operación: multiplicar pm2_5 por 1.1 (aumenta un 10%)
);

// 2.3.3. (Verificación opcional del cambio)
print("\n   --- 2.3.3. Verificando cambio de PM2.5 en un sensor de Bogotá ---");
db.lecturas_sensores.find(
    {"ubicacion.ciudad": "Bogota"},
    {"sensor_id": 1, "mediciones.pm2_5": 1, "_id": 0}
).limit(1).pretty();


// --- 2.4. DELETE (Eliminar documentos) ---
print("\n--- 2.4. Eliminando documentos (DELETE) ---");

// 2.4.1. Eliminar un solo documento: El sensor recién insertado (SNSR-NEW-007)
print("\n   --- 2.4.1. Eliminando el sensor SNSR-NEW-007 ---");
// Simula el retiro definitivo de un sensor del sistema.
db.lecturas_sensores.deleteOne({"sensor_id": "SNSR-NEW-007"});

// 2.4.2. Eliminar múltiples documentos: Todas las lecturas de un sensor específico (ej. SNSR-MED-002)
print("\n   --- 2.4.2. Eliminando todas las lecturas del sensor SNSR-MED-002 ---");
// Útil si un sensor es dado de baja y se quiere limpiar su historial de datos.
db.lecturas_sensores.deleteMany({"sensor_id": "SNSR-MED-002"});

// 2.4.3. (Verificación opcional de la eliminación)
print("\n   --- 2.4.3. Verificando eliminación del SNSR-NEW-007 ---");
db.lecturas_sensores.findOne({"sensor_id": "SNSR-NEW-007"}); // Debería retornar 'null'

// =============================================================================
// 3. PIPELINE DE AGREGACIÓN
// =============================================================================

print("\n--- 3.0. Ejecutando Operaciones de Agregación ---");

// 3.1. Contar el número de lecturas por ciudad (CORREGIDO: usando "$sum: 1")
print("\n   --- 3.1. Conteo de lecturas por ciudad ---");
// Permite conocer la distribución de los datos y la actividad de los sensores por ubicación.
db.lecturas_sensores.aggregate([
    {
        "$group": { // Primera etapa: agrupar documentos
            "_id": "$ubicacion.ciudad", // Campo por el cual se agrupa (el nombre de la ciudad)
            "total_lecturas": {"$sum": 1} // OPERADOR DE ACUMULACIÓN CORREGIDO: contar documentos en cada grupo
        }
    },
    {
        "$sort": {"total_lecturas": -1} // Segunda etapa: ordenar los resultados (descendente por total de lecturas)
    }
]);

// 3.2. Calcular promedios, máximos y mínimos de mediciones por ciudad
print("\n   --- 3.2. Estadísticas de mediciones (promedios, máximos, mínimos) por ciudad ---");
// Proporciona un resumen de las condiciones ambientales en cada ciudad, identificando tendencias y valores extremos.
db.lecturas_sensores.aggregate([
    {
        "$group": {
            "_id": "$ubicacion.ciudad",
            "promedio_temperatura": {"$avg": "$mediciones.temperatura"},
            "max_temperatura": {"$max": "$mediciones.temperatura"},
            "min_temperatura": {"$min": "$mediciones.temperatura"},
            "promedio_humedad": {"$avg": "$mediciones.humedad"},
            "max_pm2_5": {"$max": "$mediciones.pm2_5"},
            "promedio_pm2_5": {"$avg": "$mediciones.pm2_5"}
        }
    },
    {
        "$sort": {"max_pm2_5": -1} // Ordenar por el PM2.5 máximo para ver las ciudades más contaminadas
    }
]);

// 3.3. Obtener la última lectura de cada sensor
print("\n   --- 3.3. Última lectura de cada sensor ---");
// Crucial para obtener el estado actual de cada dispositivo en un dashboard en tiempo real.
db.lecturas_sensores.aggregate([
    {
        "$sort": {
            "sensor_id": 1, // Ordenar por ID de sensor
            "timestamp": -1 // Para cada sensor, la lectura más reciente primero
        }
    },
    {
        "$group": {
            "_id": "$sensor_id", // Agrupar por ID de sensor
            "ultima_lectura": {"$first": "$$ROOT"} // Tomar el primer documento completo (la última lectura) de cada grupo
        }
    }
]);

// 3.4. Contar cuántas alertas de PM2.5 (lecturas > 50) hay por ciudad y tipo de sensor (CORREGIDO: usando "$sum: 1")
print("\n   --- 3.4. Conteo de alertas PM2.5 (>50) por ciudad y tipo de sensor ---");
// Permite identificar hotspots de contaminación y qué tipos de sensores los detectan.
db.lecturas_sensores.aggregate([
    {
        "$match": { // Primera etapa: filtrar documentos que cumplen una condición
            "mediciones.pm2_5": {"$gt": 50} // Solo documentos con pm2_5 mayor a 50
        }
    },
    {
        "$group": { // Segunda etapa: agrupar los documentos filtrados
            "_id": {
                "ciudad": "$ubicacion.ciudad",  // Agrupar por combinación de ciudad
                "tipo_sensor": "$tipo_sensor"   // y tipo_sensor
            },
            "alertas_pm2_5_altas": {"$sum": 1} // OPERADOR DE ACUMULACIÓN CORREGIDO: Contar las alertas en cada grupo
        }
    },
    {
        "$sort": {"alertas_pm2_5_altas": -1} // Ordenar por el número de alertas
    }
]);

// =============================================================================
// 4. GESTIÓN DE ÍNDICES
// =============================================================================

print("\n--- 4.0. Gestión de Índices para optimización de consultas ---");

// 4.1. Crear un índice en 'ubicacion.ciudad'
print("\n   --- 4.1. Creando índice en 'ubicacion.ciudad' ---");
// Optimiza las consultas que filtran o ordenan por ciudad.
db.lecturas_sensores.createIndex({"ubicacion.ciudad": 1});

// 4.2. Crear un índice compuesto en 'sensor_id' y 'timestamp' (descendente)
print("\n   --- 4.2. Creando índice compuesto en 'sensor_id' y 'timestamp' ---");
// Mejora el rendimiento de consultas que buscan por sensor_id y necesitan las lecturas más recientes.
db.lecturas_sensores.createIndex({"sensor_id": 1, "timestamp": -1});

// 4.3. Listar todos los índices de la colección
print("\n   --- 4.3. Listando todos los índices de la colección ---");
// Confirma que los índices se han creado correctamente.
db.lecturas_sensores.getIndexes();

print("\n--- Fin de las operaciones CRUD y Agregación ---");
