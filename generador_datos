import json
import random
from datetime import datetime, timedelta

def generate_sensor_data(num_documents=120):
    """
    Genera una lista de documentos de datos de sensores IoT simulados.

    Args:
        num_documents (int): El número de documentos de sensores a generar.

    Returns:
        list: Una lista de diccionarios, donde cada diccionario representa un documento de sensor.
    """
    sensors = [
        {"id": "SNSR-BOG-001", "city": "Bogota", "country": "Colombia", "lat": 4.6097, "lon": -74.0817},
        {"id": "SNSR-MED-002", "city": "Medellin", "country": "Colombia", "lat": 6.2442, "lon": -75.5812},
        {"id": "SNSR-CAL-003", "city": "Cali", "country": "Colombia", "lat": 3.4516, "lon": -76.5320},
        {"id": "SNSR-BOG-004", "city": "Bogota", "country": "Colombia", "lat": 4.7110, "lon": -74.0721},
        {"id": "SNSR-MED-005", "city": "Medellin", "country": "Colombia", "lat": 6.2000, "lon": -75.5700}
    ]
    
    data = []
    # Genera datos para los últimos 2 días para que las fechas sean recientes
    base_time = datetime.now() - timedelta(days=2) 
    
    for i in range(num_documents):
        # Elige un sensor al azar de la lista
        sensor_info = random.choice(sensors)
        
        doc = {
            "sensor_id": sensor_info["id"],
            "ubicacion": {
                "ciudad": sensor_info["city"],
                "pais": sensor_info["country"],
                # Añade una pequeña variación a lat/lon para simular diferentes puntos en la ciudad
                "lat": round(sensor_info["lat"] + random.uniform(-0.1, 0.1), 4),
                "lon": round(sensor_info["lon"] + random.uniform(-0.1, 0.1), 4)
            },
            # Genera un timestamp incremental y con segundos aleatorios para cada lectura
            "timestamp": (base_time + timedelta(minutes=i * 2, seconds=random.randint(0, 59))).isoformat() + "Z",
            "tipo_sensor": "Calidad del Aire",
            "metadatos": {
                "modelo": random.choice(["AQ-Pro", "EnviroSense", "ClimaTrack"]),
                "fabricante": random.choice(["TechSensors Inc.", "GreenTech Solutions"])
            },
            "mediciones": {
                "temperatura": round(random.uniform(15.0, 30.0), 2),
                "humedad": round(random.uniform(40.0, 90.0), 2),
                "pm2_5": round(random.uniform(5.0, 80.0), 2), 
                # CO2 y presión son opcionales (simula sensores que no los tienen)
                "co2": round(random.uniform(350.0, 800.0), 2) if random.random() > 0.3 else None, 
                "presion": round(random.uniform(980.0, 1020.0), 2) if random.random() > 0.2 else None
            },
            "estado_bateria": random.randint(10, 100) # Estado de batería aleatorio
        }
        # Introduce algunos valores de pm2_5 altos para pruebas de alertas
        if random.random() < 0.15: # 15% de probabilidad de tener pm2_5 alto (contaminación)
            doc["mediciones"]["pm2_5"] = round(random.uniform(50.0, 120.0), 2)
            
        data.append(doc)
        
    return data

if __name__ == "__main__":
    # Genera 120 documentos (lecturas de sensores)
    generated_data = generate_sensor_data(num_documents=120) 
    # Imprime los datos en formato JSON con indentación para fácil lectura
    print(json.dumps(generated_data, indent=4))
